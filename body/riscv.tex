% !Mode:: "TeX:UTF-8"

\chapter{RISC-V相关硬件机制}[riscv]
\label{chapter:riscv}

本章将简要介绍RISC-V规范中所规定的相关机制，主要聚焦于中断处理和内存管理，这两部分尤其需要硬件与软件配合，所以了解其硬件机制对于实现操作系统的相关模块尤为重要。

为了保证架构的可扩展性，RISC-V采用了模块化设计，包括几个可以互相替换的基本指令集，以及额外可以选择的扩展指令集。本章及其后的内容将基于RV64I，这是一个最基础的整数指令集，并且不会涉及扩展指令集。

\section{RISC-V特权级}

RISC-V规范规定，在任何情况下，RISC-V硬件线程（hart）都运行在某个特权等级下，这些特权级由一个或者多个控制寄存器（CSR）编码表示。目前RV64I标准定义的三个特权级如表\ref{tab:privilege}。

\begin{table}[h]
	\centering
	\setlength{\belowcaptionskip}{2pt}
	\caption{RISC-V的三种特权等级}
	\label{tab:privilege}
	\begin{tabular}{|c|c|c|c|}
		\hline
		等级 & 编码 & 名称                          & 简写 \\ \hline
		0  & 00 & 用户/应用程序模式（User/Application） & U  \\ \hline
		1  & 01 & 监管者模式（Supervisor）           & S  \\ \hline
		2  & 10 & 未定义                         &    \\ \hline
		3  & 11 & 机器模式（Machine）               & M  \\ \hline
	\end{tabular}
\end{table}

如果当前指令试图执行当前特权模式不允许的操作，将引发异常。这些异常通常会导致自陷以进入底层执行环境进行处理。

所有的硬件实现都必须提供M-Mode，因为这是唯一可以自由访问整个机器的模式。最简单的RISC-V系统实现可能只提供M-Mode，但这种实现不会对系统提供保护以防止错误或是恶意的应用程序代码。通常，一个类Unix系统通常将M-Mode作为Bootloader的运行模式，需要实现S-Mode作为操作系统的主要运行状态，并对软件提供U-Mode的运行环境。

\section{RISC-V中断机制}

RISC-V中，能引起CPU从低权限特权级向高权限特权级转移的方式只有一种，那就是通过中断。

微观上，我们使用异常来表示当前硬件线程中执行代码发生的特殊情况，而中断则表示一个外部的异步事件，这个事件可能引起控制转移，通常与当前执行代码无关。宏观上，我们将其统称为中断。

RISC-V架构通过mstatus中的三个权限位管理全局的中断使能，分别是MIE、SIE和UIE。当硬件线程以x-Mode运行时，xIE=1时全局启用中断，xIE=0时全局禁用中断，全局启用中断意味着，在该模式下运行的线程会被中断打断，并进入到中断处理流程中。

为了细化中断粒度，RISC-V启用了另一对寄存器：mip与mie。规范将RISC-V中断分为三种，分别是定时器中断、软件中断和外部中断。定时器中断是由外部定时器（通常位于主板上）定时向CPU引脚发送中断信号引发的，软件中断是由正在执行的程序主动自陷导致，而外部中断，则是由外部设备（如键盘等设备）向CPU发送中断信号导致，通常是向CPU请求处理外部状况。只有mip和mie寄存器中的位i（i 指时钟、软件或外部中断）被设置为1，且全局启用了中断，CPU才能响应i中断。

当一个中断发生时，如果开启了对应类别的中断，并且全局使能中断，那么当前硬件线程的执行流程会被打断，控制转移到中断处理程序。mtvec寄存器配置控制转移过程，该寄存器由一个向量基地址（BASE）和向量模式（MODE）组成。MODE模式决定了CPU如何按照BASE的值进行跳转，如表\ref{tab:mtvec}。

\begin{table}[h]
	\centering
	\setlength{\belowcaptionskip}{2pt}
	\caption{mtvec中MODE字段}
	\label{tab:mtvec}
	\begin{tabular}{|c|c|c|}
		\hline
		MODE             & 名称       & 描述                                        \\ \hline
		0                & Direct   & 所有中断发生时，都会跳转到BASE处                        \\ \hline
		1                & Vectored & 中断发生时，跳转到BASE+4*xcause中所保存的地址处 \\ \hline
		\textgreater{}=2 & —        & —                                         \\ \hline
	\end{tabular}
\end{table}

在中断处理结束后，可以通过xRET指令从中断处理中返回。当执行xRET指令后，控制会跳转到xepc寄存器中的地址处，且特权模式会被设置为xPP寄存器中保存的模式。我们可以借助这种机制来完成从高权限特权级向低权限特权级的转换。

\section{RISC-V内存管理}

RISC-V采用分页机制来对内存进行管理。RISC-V中，一页是连续的4K字节（和大多数平台一致）。RISC-V中设置了三种分页模式来应对不同场景下的内存管理需求，实现时只需要根据平台特性选择一种即可。

RISC-V规范要求虚拟地址空间实现在S-Mode中，所以地址翻译相关的寄存器只有S-Mode视图的版本。其中，satp寄存器控制了地址翻译和保护。satp被划分为三个字段，其中，MODE字段用来开启分页并选择分页系统，PPN字段是根页表的物理页号。MODE字段可选编码如表\ref{tab:satpmode}。

\begin{table}[h]
	\centering
	\setlength{\belowcaptionskip}{2pt}
	\caption{satp中MODE字段}
	\label{tab:satpmode}
	\begin{tabular}{|c|c|c|}
		\hline
		MODE             & 名称       & 描述                                        \\ \hline
		0                & Bare       & 不开启分页                                   \\ \hline
		1                & Sv32       & 基于页的32位虚拟地址系统                      \\ \hline
		8                & Sv39       &          基于页的39位虚拟地址系统                      \\ \hline
		9                & Sv48       & 基于页的48位虚拟地址系统                      \\ \hline
	\end{tabular}
\end{table}

对于RV32来说，开启分页的模式只有Sv32。而RV64可以选用Sv39和Sv48。这几种分页模式基本只有地址长度上的区别，以下以SV39为例。

在Sv39中，物理地址有56位，而虚拟地址有64位。虽然虚拟地址有这么多位，但是其中只有低39位有效，第63~39位的值必须等于第38位。将虚拟地址映射为物理地址，整个地址翻译过程的通过查询页表进行的。通常，一个页表恰好占据一页，一个页表项为64位，一级页表可以存放下512个页表项。由于页表占用内存的问题，Sv39提供了对多级页表的支持。更具体的实现机制在第 \ref{chapter:memory} 章具体描述。