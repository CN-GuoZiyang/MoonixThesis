% !Mode:: "TeX:UTF-8"

\chapter{内存管理模块设计与实现}[memory]
\label{chapter:memory}

\section{模块概述}

Moonix采用两种粒度来对可用的内存进行管理。一种是动态内存分配，另一种是按页进行的内存分配。动态内存分配用于在运行时程序主动请求少量内存的情况。对Moonix来说，动态内存分配的目标是BSS段中一个8 MB大的内存空间；对于应用程序来说，应用程序运行环境也为每个进程都提供了一片内存空间用于动态内存分配。Moonix采用Buddy System Allocation算法来对堆空间进行管理，并按照最小64字节的粒度对堆空间进行划分分配。按页内存分配的分配主体是除去内核以外的所有空闲物理内存，Moonix使用一棵线段树来维护这段内存空间的使用情况。这两种分配都采用外挂式数据结构实现，以降低侵入性和代码耦合度。Moonix同样需要借助按页内存分配来实现物理内存映射到虚拟内存空间。

Moonix采用Rv64架构提供的Sv39系统来实现虚拟内存。在操作系统初始化时，Moonix就会将内核映射到虚拟地址空间，并在创建用户进程的时候都会创建独立的虚拟地址空间，即创建不同的页表来表示不同的映射模式。这样可以将不同进程的代码和数据隔离，在切换到进程时，需要切换到对应进程的页表，这部分将在第 \ref{chapter:thread} 章具体描述。

\section{动态内存分配}

\subsection{Buddy System Allocation算法概述}

动态内存分配是在程序运行过程中，程序动态请求内存空间，操作系统响应而进行的内存分配。通常，操作系统会为每个进程分配一块内存空间，该进程执行过程中的动态内存分配都在这块内存上进行。那么该使用怎么的策略进行内存分配就成了操作系统亟待解决的问题。

一个很简单的想法就是，我们可以不断地分配最小的可用地址，这样一直分配下去，内存看起来都是连续的。
但是，在此过程中，如果中间有一块内存被回收了，那么这块内存即使是可用的，但是由于其两边都是被占用的内存，这块空闲区间已经无法被扩展，最终形成外部碎片。
随着不断回收和分配内存，整块内存区间可能产生越来越多的外部碎片，以至于某个时刻，我们可能需要分配一块较大的内存，几个外部碎片的空间之和是足够的，但是单个外部碎片是无法满足需要的。这时可能会想到JVM中的标记整理算法，通过将所有可用的内存向一边移动，来减少外部碎片，这种方式的开销较大，因为操作系统不得不同步更改所有代码或数据中的地址。

Buddy System Allocation是一种经典的内存分配算法，同时也是Linux内核底层所使用的内存分配算法。它基于一种特殊的“分离适配”思想，将内存按2的幂进行划分，相当于分离出若干个块大小一致的空闲链表，搜索该链表并给出同需求最佳匹配的大小。该算法的优点是快速搜索合并（O(logN)）时间复杂度）以及低外部碎片（最佳适配）。该算法的缺点是缺点是内部碎片，譬如按2的幂划分块，如果碰上分配66个单位，那么必须划分128单位的块。该算法描述如算法：

\subsection{动态内存分配实现}

Moonix使用一棵二叉树来存储每一级范围内的最大连续空闲块个数

\section{按页内存分配}

\subsection{Moonix物理内存空间}

\subsection{基于线段树的按页内存分配实现}

\section{虚拟地址空间}

\subsection{Sv39机制概述}

\subsection{三级页表的实现}